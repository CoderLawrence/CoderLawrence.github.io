<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lawrence&#39;s Blogs</title>
  
  <subtitle>不东就西，无问西东</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://CoderLawrence.github.io/"/>
  <updated>2020-03-03T09:12:18.628Z</updated>
  <id>https://CoderLawrence.github.io/</id>
  
  <author>
    <name>CoderLawrence</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>block为什么要用copy来修饰</title>
    <link href="https://CoderLawrence.github.io/2020/03/03/block%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8copy/"/>
    <id>https://CoderLawrence.github.io/2020/03/03/block为什么要用copy/</id>
    <published>2020-03-03T01:11:40.000Z</published>
    <updated>2020-03-03T09:12:18.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间因为打算换工作，本来以为我已经复习好做好面试的准备了，结果约了一场面试，面试官问我了这个问题，我竟然回答得不知所措，所以赶紧学习脑补一下</p><h3 id="关于block为什么要使用copy修复符，首先我们要了解一下关于栈区和堆区的概念"><a href="#关于block为什么要使用copy修复符，首先我们要了解一下关于栈区和堆区的概念" class="headerlink" title="关于block为什么要使用copy修复符，首先我们要了解一下关于栈区和堆区的概念"></a>关于block为什么要使用copy修复符，首先我们要了解一下关于栈区和堆区的概念</h3><ul><li>内存的栈区：由编译器自动分配和释放，存放函数的参数值，局部变量的值等，其操作类似数据结构的栈。</li><li>内存的堆区：一般由程序员分配和释放，若程序员不释放，程序结束时可能有OS进行回收，注意这里的内存堆区与数据结构中的堆是两回事，分配方式倒是类似于链表。</li></ul><h3 id="在iOS中block的类型"><a href="#在iOS中block的类型" class="headerlink" title="在iOS中block的类型"></a>在iOS中block的类型</h3><p>想必很多开发人员知道一般用copy修饰block，但是为什么要使用copy来修饰呢，其实在Objective-C语言中，一共有3中类型的block：</p><ul><li>_NSConcreteGlobalBlock 全局的静态 block，不会访问外部局部变量（显然包括无外部变量或者全局变量）</li><li>_NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。</li><li>_NSConcreteMallocBlock 保存在堆中的 block，当应用计数为 0 时</li></ul><p>测试代码代码（摘自网络）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="keyword">void</span>(^demoBolck)();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="keyword">void</span>(^demoBolck1)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">8</span>;<span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (^demoBolck)() = ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"indemoBolck"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"demoBolck %@"</span>,demoBolck);    <span class="comment">//&lt;__NSGlobalBlock__: 0x1085af0e0&gt;  无论ARC还是MRC下，因不访问外部局部(包括无外部变量或者只有全局变量)，NSGlobalBlock表示在全局区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (^demoBolck4)() = ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"indemoBolck4  %d"</span>,b);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"demoBolck4 %@"</span>,demoBolck4);    <span class="comment">//&lt;__NSGlobalBlock__: 0x10150b120&gt;  全局区</span></span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">int</span> a = <span class="number">6</span>;   <span class="comment">//block内部引用a，并修改其值，需要用block修饰，不然可以不用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (^demoBolck2)() = ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"indemoBolck2 %d"</span>,a++);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    demoBolck2();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"demoBolck2 %@,%d"</span>,demoBolck2,a);   <span class="comment">//&lt;__NSMallocBlock__: 0x600000056c50&gt; ARC下堆区,在ARC模式下,系统也会默认对Block进行copy操作，Block的内存地址这时候便显示在堆区 &lt;__NSStackBlock__: 0x7fff5d0ada28&gt;MRC下在栈区</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"demoBolck2.Copy %@"</span>,[demoBolck2 <span class="keyword">copy</span>]);    <span class="comment">//&lt;__NSMallocBlock__: 0x600000056c50&gt;copy操作不管MRC或者ARC都在堆区，只是在MRC下进行copy会改变地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.demoBolck = demoBolck2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self.demoBolck %@"</span>,<span class="keyword">self</span>.demoBolck);<span class="comment">//堆区&lt;__NSMallocBlock__: 0x608000052630&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.demoBolck1 = demoBolck2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.demoBolck1();     <span class="comment">//demoBolck2  7   能执行无问题</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self.demoBolck1 %@"</span>,<span class="keyword">self</span>.demoBolck1);     <span class="comment">//&lt;__NSMallocBlock__: 0x600000056c50&gt;  strong修饰ARC和MRC都并没有问题, 但是assign和retain在MRC环境下是还是在栈区的，会有问题</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：MRC环境下:demoBolck1用assign，retain修饰，栈区：&lt;__NSStackBlock__: 0x7fff50915a50&gt;，提前释放了所以运行到下面语句程序会崩溃。ARC环境下：用copy，strong, assign, retain修饰是可以正常打印出结果的。 无论什么环境，用copy，strong修饰是可以正常打印出结果的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.demoBolck1();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>注意：测试代码需要把创建的类对象改成MRC才能打印到对应的数据 <code>-fno-objc-arc</code></p><h3 id="关于为什么block是copy来修饰，这涉及到block作用域的问题"><a href="#关于为什么block是copy来修饰，这涉及到block作用域的问题" class="headerlink" title="关于为什么block是copy来修饰，这涉及到block作用域的问题"></a>关于为什么block是copy来修饰，这涉及到block作用域的问题</h3><p>首先，block是一个对象，所以block理论上是可以retain/release的，但是block在创建的时候它的内存默认是分配在栈（stack）上，而不是堆（heap）上的。所以它的作用域仅限创建时候的当前上下文（函数，方法，…)，当你在该作用域外调用该block时，程序就会崩溃，所以为什么block需要使用copy来修饰，其实目的就是为了把它从内存的栈上挪动到内存的堆上，把其作用域扩大。</p><ul><li>官方文档：</li></ul><p><img src="/2020/03/03/block为什么要用copy/copy_block.png" alt="Alt text"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>block内部没有调用外部局部变量时存放在全局区（ARC和MRC下均是）</li><li>block使用了外部局部变量，这种情况下也是我们平时所常用的方式。MRC：block的内存地址显示在栈区，栈区的特点就是创建的对象随时可能被销毁，一旦被销毁后续再次调用空对象就可能会造成程序奔溃，在对block进行copy后，block存在堆区，所以在使用block属性时使用copy修饰，但是在ARC中的block都会在堆上，系统会默认对block进行copy操作</li><li>用copy，strong修饰block在ARC和MRC都是可以的，都是在堆区</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>一个block要使用self，会处理成在外部声明一个weak变量指向self，然而为何会出现在block里又声明一个strong变量指向weaSelf?<br>原因：block会把写在block里的变量copy一份，如果直接在block里使用self，（self对变量默认是强引用）self对block持有，导致循环引用，所以这里需要声明一个弱引用weakSelf，让block应用weakSelf，打破循环应用。<br>而这样会导致另外一个问题，因为weakSelf是对self的弱应用，如果这个时候控制器pop或者其他方式导致引用计数变为0，就会被释放，如果这个block是异步调用而且调用的时候self已经释放了，这个时候weakSelf已经变成了nil.<br>当控制器（也可以是其他对象）pop回来之后（或者一些其他的原因导致释放），网络请求完成，如果这个时候需要控制器做出反映，需要strongSelf再对weakSelf强引用一下。<br>但是，你可能会有疑问，strongSelf对weakSelf强引用，weakSelf对self弱引用，最终也不是对self进行了强引用，会导致循环引用，答案是不会的，因为strongSelf是在block里面声明的一个指针，当block执行完毕后，strongSelf会释放，这时候讲不再强引用weakSelf，所以self会正确释放。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>一般情况下你不需要自行调用copy或者retain一个block，只有当你需要在block定义域以外的地方使用时才需要copy，copy将block从内存栈区移到堆区。</li><li>其实block使用copy是MRC留下来的也算是一个传统吧，在MRC下，如上述，在方法中的block创建在栈区，使用copy就能把他放到堆区，这样在作用域外调用block程序就不会奔溃。</li><li>在ARC下，使用copy与strong其实都一样，因为block的retain就是用copy来实现的，所以block使用copy还能装装逼，所以自己是从MRC下走过来的。</li></ul>]]></content>
    
    <summary type="html">
    
      前段时间因为打算换工作，本来以为我已经复习好做好面试的准备了...
    
    </summary>
    
      <category term="iOS" scheme="https://CoderLawrence.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://CoderLawrence.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS10自定义推送UI和推送内容（上）</title>
    <link href="https://CoderLawrence.github.io/2018/08/06/iOS%E5%88%A9%E7%94%A8UserNotifications%E6%A1%86%E6%9E%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A8%E9%80%81UI%E5%92%8C%E6%8E%A8%E9%80%81%E5%86%85%E5%AE%B9/"/>
    <id>https://CoderLawrence.github.io/2018/08/06/iOS利用UserNotifications框架自定义推送UI和推送内容/</id>
    <published>2018-08-06T15:11:33.000Z</published>
    <updated>2018-08-11T07:13:01.826Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>iOS10这个系统已经出来一年多了，那时候系统刚发布的时候也做过iOS10推送的适配，但是那时候推送是集成第三方的，所以对新的系统的推送的升级不是很了解，UserNotifications.frameworks和UserNotificationUI.frameworks是在iOS10上发布的，可以认为是通知大改版，用于在新系统上替换久的通知框架，苹果给了我们一个能够自定义推送的一个机会，但是因为那是时候的工作没有涉及到这一块，只是对iOS10上的新通知框架有个初步的了解，并没有深入学习这两个新的推送框架，因为最近产品上有这样的需求，需要自定义推送的UI和统计推送的送达率等，所以对这两个框架进行了深入的学习，并且写篇文章总结一下，本篇文章最要是围绕着Notification Service Extension和Notification Content Extension来展开，有关iOS10系统的通知特性请看文章下面推荐的文章。</p><h3 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h3><p>在深入学习之前，如果大家没有看过iOS10推送相关的内容，这里推荐一篇文章供大家学习和了解一下iOS10推送相关的一些知识，本篇文章涉及的内容跟下面的文章会有所关联，当然会深入一些，学习嘛~需要循序渐进</p><ul><li><a href="https://www.jianshu.com/p/f5337e8f336d" target="_blank" rel="noopener">iOS开发 iOS10推送必看(基础篇)</a></li><li><a href="https://www.jianshu.com/p/bb89d636f989" target="_blank" rel="noopener">iOS开发 iOS10 推送通知 UserNotifications</a></li></ul><h3 id="自定义推送内容"><a href="#自定义推送内容" class="headerlink" title="自定义推送内容"></a>自定义推送内容</h3><p>在iOS 10以上版本的系统，苹果推送了Notification Service Extension（通知内容扩展）给我们自定义推送的内容</p><h4 id="1、Notification-Service-Extension简介"><a href="#1、Notification-Service-Extension简介" class="headerlink" title="1、Notification Service Extension简介"></a>1、Notification Service Extension简介</h4><p>Notification Service Extension是在iOS10推出后的一个新的通知特性，原理如下图（图片来源网络）：</p><p><img src="/2018/08/06/iOS利用UserNotifications框架自定义推送UI和推送内容/NotificationServiceExtension_2.png" alt="Alt text"></p><p>从图片我们可以看出，当手机接收到APNs推送给用户的消息后，中间添加了Service Extension这一个处理的步骤（当然也可以啥都不处理），通过这个扩展我们可以把我们要自定义的内容的处理放在这个步骤里面做，然后再呈现给用户，使得推送的内容更加丰富化，当然这里是有时间限制的（后面会详细讲）</p><h4 id="2、Notification-Service-Extension能做些什么事情"><a href="#2、Notification-Service-Extension能做些什么事情" class="headerlink" title="2、Notification Service Extension能做些什么事情"></a>2、Notification Service Extension能做些什么事情</h4><ul><li>统计推送送达率</li><li>自定义内容，推送内容丰富化</li><li>安全，可以防止推送内容被拦截和篡改</li></ul><h4 id="3、Notification-Service-Extension构建和使用"><a href="#3、Notification-Service-Extension构建和使用" class="headerlink" title="3、Notification Service Extension构建和使用"></a>3、Notification Service Extension构建和使用</h4><p>如果有使用过Extension的同学都知道，其实Extension在工程里面就是一个target，那么Noification Service Extension也不例外也是一个target：</p><p><img src="/2018/08/06/iOS利用UserNotifications框架自定义推送UI和推送内容/NotificationServiceExtension_3.png" alt="Alt text"></p><p>接着选择Notification Service Extension，如下图：</p><p><img src="/2018/08/06/iOS利用UserNotifications框架自定义推送UI和推送内容/NotificationServiceExtension_1.png" alt="Alt text"></p><p>完成后就会在主工程上看到对应的Notification Service Extension的target:</p><p><img src="/2018/08/06/iOS利用UserNotifications框架自定义推送UI和推送内容/NotificationServiceExtension_4.png" alt="Alt text"></p><p>在Notification Service Extension里面会看到有两个函数：</p><p><img src="/2018/08/06/iOS利用UserNotifications框架自定义推送UI和推送内容/NotificationServiceExtension_5.png" alt="Alt text"></p><p>通知的内容自定义在这个函数处理，可以处理附件的下载、推送内容修改、推送送达率的统计等:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> request: UNNotificationRequest, withContentHandler contentHandler: @escaping <span class="params">(UNNotificationContent)</span></span></span> -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure><p>这个函数是当你接收到一条远程通知后，系统会调用override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void)这个函数给你处理通知的内容，当然系统也不会给很长的时间，长时间等待会造成体验不好什么的，系统只给你30秒的时间处理，如果处理不完会调用override func serviceExtensionTimeWillExpire()这个函数,如果你还不做出相应的操作，那么将显示最开始的通知的内容。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">serviceExtensionTimeWillExpire</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>例如推送统计送达率，推送送达率其实就是手机接收到通知后，系统调起了Notification Service Extension，那么这时候在接收到通知的回调里面，发送一个请求告诉服务端手机客户端已经接收到这条通知，以达到推送送达率统计的目的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> request: UNNotificationRequest, withContentHandler contentHandler: @escaping <span class="params">(UNNotificationContent)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.contentHandler = contentHandler</span><br><span class="line">        bestAttemptContent = (request.content.mutableCopy() <span class="keyword">as</span>? <span class="type">UNMutableNotificationContent</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//TODO 推送统计通达率</span></span><br><span class="line">        <span class="keyword">let</span> url: <span class="type">URL</span> = <span class="type">URL</span>.<span class="keyword">init</span>(string: <span class="string">"your https address"</span>)!</span><br><span class="line">        <span class="keyword">let</span> urlRequest: <span class="type">URLRequest</span> = <span class="type">URLRequest</span>.<span class="keyword">init</span>(url: url)</span><br><span class="line">        <span class="keyword">let</span> urlSession: <span class="type">URLSession</span> = <span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span>)</span><br><span class="line">        <span class="keyword">let</span> task: <span class="type">URLSessionDataTask</span> = urlSession.dataTask(with: urlRequest) &#123; (data, res, error) <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//统计完了回调通知</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> bestAttemptContent = <span class="keyword">self</span>.bestAttemptContent &#123;</span><br><span class="line">                bestAttemptContent.title = <span class="string">"\(bestAttemptContent.title) [modified]"</span></span><br><span class="line">                contentHandler(bestAttemptContent)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>例如内容自定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> request: UNNotificationRequest, withContentHandler contentHandler: @escaping <span class="params">(UNNotificationContent)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.contentHandler = contentHandler</span><br><span class="line">        bestAttemptContent = (request.content.mutableCopy() <span class="keyword">as</span>? <span class="type">UNMutableNotificationContent</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 修改推送的标题和内容等</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> bestAttemptContent = <span class="keyword">self</span>.bestAttemptContent &#123;</span><br><span class="line">            bestAttemptContent.title = <span class="string">"这是我自定义推送的标题！！！🐶🐶"</span></span><br><span class="line">            bestAttemptContent.body = <span class="string">"这是我自定义推送的内容！！！🍎🍐"</span></span><br><span class="line">            contentHandler(bestAttemptContent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4、Notification-Service-Extension配置"><a href="#4、Notification-Service-Extension配置" class="headerlink" title="4、Notification Service Extension配置"></a>4、Notification Service Extension配置</h4><p>前面说到Extension是一个target，那么就会涉及到打包相关的工作，这里需要配置对应的bundle identifier和打包的描述文件：</p><p><img src="/2018/08/06/iOS利用UserNotifications框架自定义推送UI和推送内容/NotificationServiceExtension_6.png" alt="Alt text"></p><p>推送环境的配置和勾选，需要开启push Notifications配置：</p><p><img src="/2018/08/06/iOS利用UserNotifications框架自定义推送UI和推送内容/NotificationServiceExtension_7.png" alt="Alt text"></p><p>假如你需要在网络上下载一些资源或者是一些数据请求，那么需要配置info.plist文件允许网络访问权限（如果不配置会导致程序奔溃）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h3><p>对于Notification Service Extension的调试，我在开发的过程中遇到了不少的问题，也花了不少的时间去查资料等，国内这一块的资料比较少而且也不全面，所以这里补充一下我遇到的问题和才到的坑</p><ul><li><p>程序编译了，当接收到通知的时候代码没有起作用，其实是调试的方式不对，首先是要调试主工程，然后再调试Notifcation Service Extension，再回到主工程调试Notification Service Extension的代码就会执行，你修改的内容就会在通知上看到</p></li><li><p>关于debug断点，是要在主工程的调试的时候去监听Notification Service Extension 才能断点，不能直接在Notification Service Extension调试的时候去断点调试，如果在这里调试可以在macOS的控制台App中看到Notification Service Extension启动后被系统kill了</p></li><li><p>关于前面连个步骤都不能起效果，是因为你的APNs推送的数据个数不对，需要加上<code>mutable-content</code>字段</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aps"</span>: &#123;</span><br><span class="line">        <span class="attr">"alert"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"推送测试"</span>,</span><br><span class="line">            <span class="attr">"body"</span>: <span class="string">"推送内容"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="number">20</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"badge"</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="attr">"sound"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="attr">"mutable-content"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"category"</span>: <span class="string">"customUI"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推送调试工具"><a href="#推送调试工具" class="headerlink" title="推送调试工具"></a>推送调试工具</h3><p>这里安利大家两个能够不需要服务器配置也能够测试的小工具</p><ul><li><a href="https://github.com/shaojiankui/SmartPush" target="_blank" rel="noopener">SmartPush</a></li><li>Easy APNs Provider，App Store可以下载</li></ul>]]></content>
    
    <summary type="html">
    
      iOS利用Notification Service Extension和Notification Content Extension自定义推送内容和UI
    
    </summary>
    
      <category term="iOS开发" scheme="https://CoderLawrence.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://CoderLawrence.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Android开发环境搭建</title>
    <link href="https://CoderLawrence.github.io/2018/05/24/Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://CoderLawrence.github.io/2018/05/24/Android开发环境搭建/</id>
    <published>2018-05-24T03:22:01.000Z</published>
    <updated>2018-06-22T03:20:31.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一名iOS攻城狮，因为工作需要除了iOS开发之外，想要拓展一下移动端开发的知识，所以想要窥探一下Android开发的一下知识，了解一下Android一门技术的设计语言和规范等，Android这一门技术还是在大学的时候接触过，应该变化很大了，于是趁着工作之余搭建一下Android开发的集成环境，作为一名Android开发的门外汉觉得还是有必要总结一下Android开发的环境的搭建的。</p><h3 id="Java环境配置"><a href="#Java环境配置" class="headerlink" title="Java环境配置"></a>Java环境配置</h3><p>我本人使用的是macOS系统，这里以macOS为例讲解Java环境的配置</p><ul><li><p>JDK 下载</p><p>我这里使用的是 Java 8，据说Java 9 Android Studio支持还没有那么好 JDK下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Oracle官网</a></p></li><li><p>JDK 安装</p><p>下载完JDK后直接点击打开pkg安装包然后安装即可</p></li><li><p>JDK 环境变量配置</p><ul><li>如果你是第一次配置环境变量，可以代码终端然后输入<code>touch .bash_profile</code> 来创建一个.bash_profile的隐藏配置文件</li></ul><p><img src="/2018/05/24/Android开发环境搭建/1.png" alt="Alt text"></p><ul><li>如果你已经配置过环境变量那么在终端下使用如下指令打开.bash_profile文件<code>open -e .bash_profile</code></li></ul><p><img src="/2018/05/24/Android开发环境搭建/2.png" alt="Alt text"></p><ul><li><p>添加环境变量到.bash_profile文件保存即可</p><p><code>JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home&quot;export JAVA_HOMECLASS_PATH=&quot;$JAVA_HOME/lib&quot;PATH=&quot;.$PATH:$JAVA_HOME/bin&quot;</code></p></li></ul></li><li><p>测试JDK是否配置成功</p><p>终端下输入如下指令: <code>java -version</code></p><p><img src="/2018/05/24/Android开发环境搭建/3.png" alt="Alt text"></p></li></ul><h3 id="Android-Sutdio-环境配置"><a href="#Android-Sutdio-环境配置" class="headerlink" title="Android Sutdio 环境配置"></a>Android Sutdio 环境配置</h3><ul><li><p>Android Sutdio 下载</p><ul><li><a href="http://www.android-studio.org/index.php/download" target="_blank" rel="noopener">IDE下载地址</a></li></ul></li><li><p>IDE 安装</p><ul><li>下载完安装包后安装IDE即可</li></ul></li><li><p>我现在下载Android Studio之后之前是要科学上网的，现在不需要科学上网了。</p></li><li><p>至此Android Studio开发环境相关配置已经配置完成，Android SDK版本相关的下载这里不再赘述，执行上网找Android Studio使用的相关教程。</p></li></ul>]]></content>
    
    <summary type="html">
    
      iOS开发的Android小白搭建Android开发环境之路。
    
    </summary>
    
      <category term="Android" scheme="https://CoderLawrence.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://CoderLawrence.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <link href="https://CoderLawrence.github.io/2018/05/22/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://CoderLawrence.github.io/2018/05/22/Hexo-Github搭建个人博客/</id>
    <published>2018-05-22T03:29:58.000Z</published>
    <updated>2018-05-22T08:43:59.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一开始接触写代码的时候我就想搭一个自己个人的技术博客，用来记录平常开发时遇到的问题和平时的一些学习等，但是那时候不知道要怎么去搭建属于自己的博客，而后工作越来越忙了这个事情就耽搁了，前段时间想逼自己记录一些自己平常时间的一些学习等，所以又萌发了重新搭建技术博客的念头，看了一波资料后决定采用Hexo+Github搭建个人博客, 因为Hexo搭建比较简单，而且Hexo使用Markdown渲染和解析文章，编写文章非常方便。</p><h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><p>Hexo 是一个快速、简介高效的博客框架。Hexo 官网地址：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><h4 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h4><p>相信很多程序员都是使用Git，所以这里不再赘述git的安装，不会使用的同学这里推荐一个<a href="https://git-scm.com/book/zh/v2/起步-安装-Git" target="_blank" rel="noopener">Git安装教程</a></p><ul><li>到你的Github账号上去建一个新的Repository，仓库名为[your_user_name.github.io]，没有Github账号的同学到这里去申请<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></li><li>后续想要把网址部署到Github上的同学，需要在【your_user_name.github.io】此仓库下的Setting配置里添加一个Deploy keys</li></ul><h4 id="创建-SSH-key可以参考："><a href="#创建-SSH-key可以参考：" class="headerlink" title="创建 SSH key可以参考："></a>创建 SSH key可以参考：</h4><ul><li><a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/" target="_blank" rel="noopener">https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/</a></li></ul><h4 id="Homebrew安装"><a href="#Homebrew安装" class="headerlink" title="Homebrew安装"></a>Homebrew安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><h4 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h4><h5 id="直接使用homebrew安装"><a href="#直接使用homebrew安装" class="headerlink" title="直接使用homebrew安装"></a>直接使用homebrew安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure><h5 id="下载Node-js包安装"><a href="#下载Node-js包安装" class="headerlink" title="下载Node.js包安装"></a>下载Node.js包安装</h5><p>Node.js下载地址<a href="https://nodejs.org" target="_blank" rel="noopener">https://nodejs.org/</a></p><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>安装完成Hexo后，建立一个<code>Blog</code>文件夹，执行如下指令即可完成Hexo初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd Blog</span><br><span class="line">$ Hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><p>完成Hexo初始化后，就可以测试一下你的博客是否搭建成功，执行如下指令进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd Blog</span><br><span class="line">$ Hexo post &quot;我的一个博客&quot;</span><br><span class="line">$ Hexo g</span><br><span class="line">$ Hexo server</span><br></pre></td></tr></table></figure><p>执行如下指令后浏览器输入:<code>http://localhost:4000</code>查看本地博客是否可以访问</p><h3 id="发布博客到Github"><a href="#发布博客到Github" class="headerlink" title="发布博客到Github"></a>发布博客到Github</h3><p>完成了博客的初始化后，我们可以把我们搭建的博客发布到Github，打开<code>Blog</code>文件夹下的<code>_config.yml</code>文件，找到<code>deploy</code>，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/your_user_name/you_user_name.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>要提交到Github上需要安装hexo-deployer-git插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>等待hexo-deployer-git插件安装完成后，执行如下指令，即可完成Hexo发布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ Hexo clean</span><br><span class="line">$ Hexo g</span><br><span class="line">$ Hexo d</span><br></pre></td></tr></table></figure><p>到了这一步后耐心等待，如果遇到要输入Github账号用户名和密码，输入即可发布完成。</p><h3 id="修改Hexo默认主题"><a href="#修改Hexo默认主题" class="headerlink" title="修改Hexo默认主题"></a>修改Hexo默认主题</h3><p>我这里的博客主题是使用了<code>next</code>主题，需要自定义主题的可以到以下地址查看教程修改: </p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a><br><a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><h3 id="Hexo-写文章"><a href="#Hexo-写文章" class="headerlink" title="Hexo 写文章"></a>Hexo 写文章</h3><p>博客搭建完成后，可以开心的记录你的学习啊，个人心得什么的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd Blog</span><br><span class="line">$ Hexo new post &quot;xxxxxxx&quot;</span><br></pre></td></tr></table></figure><p>完成文章编写后，可以重新发布到Github，指令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ Hexo clean</span><br><span class="line">$ Hexo g</span><br><span class="line">$ Hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用Hexo+Github搭建属于自己的个人博客，从此不再羡慕别人。
    
    </summary>
    
      <category term="Hexo教程" scheme="https://CoderLawrence.github.io/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="https://CoderLawrence.github.io/tags/Hexo/"/>
    
      <category term="web" scheme="https://CoderLawrence.github.io/tags/web/"/>
    
  </entry>
  
</feed>
